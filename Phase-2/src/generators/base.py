"""Abstract Base Generator"""
from abc import ABC, abstractmethod
from pathlib import Path
from typing import List
from ..models.metadata import Metadata, Table, Column
from ..utils.logger import get_logger

logger = get_logger(__name__)

class SQLGenerator(ABC):
    """Abstract base class for SQL generators"""
    
    def __init__(self, metadata: Metadata, output_dir: Path):
        self.metadata = metadata
        self.output_dir = output_dir
        self.logger = logger
    
    @abstractmethod
    def map_type(self, generic_type: str) -> str:
        """Map generic type to database-specific type"""
        pass
    
    def generate_ddl(self) -> str:
        """Generate complete DDL"""
        self.logger.info(f"Generating {self.__class__.__name__} DDL...")
        
        ddl_parts = []
        ddl_parts.append(self._generate_header())
        ddl_parts.append("")
        ddl_parts.append(self._generate_drops())
        ddl_parts.append("")
        
        for table in self.metadata.tables.values():
            ddl_parts.append(self._generate_create_table(table))
            ddl_parts.append("")
        
        for table in self.metadata.tables.values():
            fk_statements = self._generate_foreign_keys(table)
            if fk_statements:
                ddl_parts.extend(fk_statements)
                ddl_parts.append("")
        
        for table in self.metadata.tables.values():
            index_statements = self._generate_indexes(table)
            if index_statements:
                ddl_parts.extend(index_statements)
                ddl_parts.append("")
        
        return "\n".join(ddl_parts)
    
    def _generate_header(self) -> str:
        """Generate SQL header"""
        return f"""-- Generated by Phase-2 MySQL Physical Model Generator
-- Database: MySQL
-- Tables: {len(self.metadata.tables)} | Columns: {self.metadata.total_columns}
-- DO NOT EDIT MANUALLY"""
    
    def _generate_drops(self) -> str:
        """Generate DROP statements"""
        drops = ["-- Drop existing tables (reverse order for FK dependencies)"]
        for table_name in reversed(list(self.metadata.tables.keys())):
            drops.append(f"DROP TABLE IF EXISTS {self._sanitize_name(table_name)};")
        return "\n".join(drops)
    
    @abstractmethod
    def _generate_create_table(self, table: Table) -> str:
        """Generate CREATE TABLE statement"""
        pass
    
    @abstractmethod
    def _generate_foreign_keys(self, table: Table) -> List[str]:
        """Generate foreign key statements"""
        pass
    
    @abstractmethod
    def _generate_indexes(self, table: Table) -> List[str]:
        """Generate index statements"""
        pass
    
    def _sanitize_name(self, name: str) -> str:
        """Sanitize identifier name"""
        safe_name = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        return safe_name.lower()
    
    def save(self, filename: str) -> Path:
        """Save DDL to file"""
        ddl_content = self.generate_ddl()
        output_path = self.output_dir / filename
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(ddl_content, encoding='utf-8')
        
        self.logger.info(f"âœ“ Saved: {output_path} ({len(ddl_content):,} bytes)")
        return output_path

